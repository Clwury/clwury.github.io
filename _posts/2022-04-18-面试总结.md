---
layout: post
title: 面试总结
subtitle: 问题记录
date: 2022-04-18 22:30:00
author: ODD
header-img: "img/in-post/2022-04-18-bg.jpeg"
catalog: true
tags:
    - 面试
---

### 4.18

**1、冒泡排序**(稳定排序)

```csharp
public int[] BubbleSort(int[] nums)
{
    int m = nums.Length - 1;
    // 标记某一趟排序是否发生交换
    bool flag = true;
    while (m > 0 && flag)
    {
        flag = false;
        for (int j = 0; j < m; j++)
        {
            if (nums[j] > nums[j + 1])
            {
                flag = true;
                (nums[j], nums[j + 1]) = (nums[j + 1], nums[j]);
            }
        }

        --m;
    }

    return nums;
}
```

**2、简单选择排序**(数组实现不稳定排序)

```csharp
public int[] SelectSort(int[] nums)
{
    for (int i = 0; i < nums.Length - 1; i++)
    {
        int k = i;
        for (int j = i + 1; j < nums.Length; j++)
        {
            if (nums[j] < nums[k]) k = j;
        }

        if (k != i) (nums[i], nums[k]) = (nums[k], nums[i]);
    }

    return nums;
}
```

**3、素数**

```csharp
public List<int> Prime(int n)
{
    List<int> primeNums = new List<int>();
    for (int i = 2; i <= n; i++)
    {
        bool flag = true;
        for (int j = 2; j <= i >> 1; j++)
        {
            if (i % j == 0)
            {
                flag = false;
                break;
            }
        }
        if (flag) primeNums.Add(i);
    }

    return primeNums;
}
```

### 4.27

**最短可行路径数**  
描述：在7*7网格中的每个单元格代表一个节点，求从左下角节点(6, 0)到右上角节点(0, 6)的最短可行路径数

```csharp
// 使用DFS遍历
public IList<IList<int[]>> FindWays(int[][] nums,int[] start, int[] end)
{
    int row = nums.Length, col = nums[0].Length;
    int[][] offset = {new[] {-1, 0}, new []{0, 1}};
    IList<IList<int[]>> paths = new List<IList<int[]>>();
    List<int[]> path = new List<int[]>
    {
        new []{start[0], start[1]}
    };
    foreach (var arr in offset)
    {
        int x = start[0] + arr[0];
        int y = start[1] + arr[1];
        if (x >= 0 && x < row && y >= 0 && y < col)
        {
            int[] nextPos = {x, y};
            path.Add(nextPos);
            DFS(nums, offset, nextPos, end, paths, path);
            path.RemoveAt(path.Count - 1);
        }
    }

    return paths;
}

public void DFS(int[][] nums, int[][] offset, int[] curPos, int[] end, IList<IList<int[]>> paths, List<int[]> path)
{
    if (curPos[0] == end[0] && curPos[1] == end[1])
    {
        List<int[]> clone = new List<int[]>(path.ToArray()); 
        paths.Add(clone);
        return;
    }

    foreach (var arr in offset)
    {
        int incrX = curPos[0] + arr[0];
        int incrY = curPos[1] + arr[1];
        if (incrX >= 0 && incrX < nums.Length && incrY >= 0 && incrY < nums[0].Length)
        {
            int[] nextPos = {incrX, incrY};
            path.Add(nextPos);
            DFS(nums, offset, nextPos, end, paths, path);
            path.RemoveAt(path.Count - 1);
        }
    }
}
```